<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CLobster+Two:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CUbuntu+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"shifuru.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="NOIp范围内的图论算法">
<meta property="og:type" content="article">
<meta property="og:title" content="NOIp 2018 前的图论板子总结">
<meta property="og:url" content="https://shifuru.github.io/2018/09/30/NOIp-2018-%E5%89%8D%E7%9A%84%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="FORTH">
<meta property="og:description" content="NOIp范围内的图论算法">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-09-30T14:10:00.000Z">
<meta property="article:modified_time" content="2024-08-22T11:24:13.008Z">
<meta property="article:author" content="Sifr">
<meta property="article:tag" content="图论">
<meta property="article:tag" content="Kruskal算法">
<meta property="article:tag" content="Prim算法">
<meta property="article:tag" content="Tarjan强连通分量算法">
<meta property="article:tag" content="匈牙利算法">
<meta property="article:tag" content="Kuhn-Munkres算法">
<meta property="article:tag" content="树链剖分">
<meta property="article:tag" content="Floyd-Warshall算法">
<meta property="article:tag" content="SPFA">
<meta property="article:tag" content="Dijkstra算法">
<meta property="article:tag" content="Edmonds-Karp算法">
<meta property="article:tag" content="Dinic算法">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://shifuru.github.io/2018/09/30/NOIp-2018-%E5%89%8D%E7%9A%84%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90%E6%80%BB%E7%BB%93/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://shifuru.github.io/2018/09/30/NOIp-2018-%E5%89%8D%E7%9A%84%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90%E6%80%BB%E7%BB%93/","path":"2018/09/30/NOIp-2018-前的图论板子总结/","title":"NOIp 2018 前的图论板子总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>NOIp 2018 前的图论板子总结 | FORTH</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">FORTH</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Take off, toward a dream.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%9B%BE"><span class="nav-number">1.</span> <span class="nav-text">存图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E8%BE%B9"><span class="nav-number">1.1.</span> <span class="nav-text">存边</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#adjacency-matrix"><span class="nav-number">1.2.</span> <span class="nav-text">Adjacency matrix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#adjacency-list"><span class="nav-number">1.3.</span> <span class="nav-text">Adjacency list</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">1.3.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">1.3.2.</span> <span class="nav-text">list</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kruskals-algorithm"><span class="nav-number">2.1.</span> <span class="nav-text">Kruskal&#39;s algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prims-algorithm"><span class="nav-number">2.2.</span> <span class="nav-text">Prim&#39;s algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">强连通分量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="nav-number">4.</span> <span class="nav-text">二分图最大匹配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E4%BD%B3%E5%8C%B9%E9%85%8D"><span class="nav-number">5.</span> <span class="nav-text">二分图最佳匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kuhn-munkres-algorithm"><span class="nav-number">5.1.</span> <span class="nav-text">Kuhn-Munkres algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">6.</span> <span class="nav-text">最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#heavy-path-decomposition"><span class="nav-number">6.1.</span> <span class="nav-text">Heavy path decomposition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">7.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#floyd-warshall-algorithm"><span class="nav-number">7.1.</span> <span class="nav-text">Floyd-Warshall algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shortest-path-faster-algorithmspfa"><span class="nav-number">7.2.</span> <span class="nav-text">Shortest Path Faster
Algorithm(SPFA)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dijkstras-algorithm"><span class="nav-number">7.3.</span> <span class="nav-text">Dijkstra&#39;s algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">最大流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#edmonds-karp-algorithm"><span class="nav-number">8.1.</span> <span class="nav-text">Edmonds-Karp algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dinics-algorithm"><span class="nav-number">8.2.</span> <span class="nav-text">Dinic&#39;s algorithm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="nav-number">9.</span> <span class="nav-text">最小费用最大流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dinics-algorithm-1"><span class="nav-number">9.1.</span> <span class="nav-text">Dinic&#39;s algorithm</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sifr"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Sifr</p>
  <div class="site-description" itemprop="description">悪意に満ちた人間は絶滅すべき</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/shifuru" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shifuru" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shifuru.github.io/2018/09/30/NOIp-2018-%E5%89%8D%E7%9A%84%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Sifr">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FORTH">
      <meta itemprop="description" content="悪意に満ちた人間は絶滅すべき">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="NOIp 2018 前的图论板子总结 | FORTH">
      <meta itemprop="description" content="NOIp范围内的图论算法">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NOIp 2018 前的图论板子总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-30 22:10:00" itemprop="dateCreated datePublished" datetime="2018-09-30T22:10:00+08:00">2018-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-22 19:24:13" itemprop="dateModified" datetime="2024-08-22T19:24:13+08:00">2024-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">NOIp范围内的图论算法</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="存图">存图</h1>
<h2 id="存边">存边</h2>
<p>直接开一个结构体数组存边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> begin, end, weight;</span><br><span class="line">&#125; edge[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> edge_count;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;u, <span class="type">const</span> <span class="type">int</span> &amp;v, <span class="type">const</span> <span class="type">int</span> &amp;w)</span> </span>&#123;</span><br><span class="line">  edge[edge_count++] = Edge &#123;u, v, w&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用: 1. Kruskal's algorithm</p>
<h2 id="adjacency-matrix">Adjacency matrix</h2>
<p>用二维数组<code>adj[i][j]</code>表示<span
class="math inline">\(i\)</span>与<span
class="math inline">\(j\)</span>的关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> adj[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_EDGE(u, v, w) adj[u][v] = w</span></span><br></pre></td></tr></table></figure>
<p>应用: 1. Floyd-Warshall algorithm 2. Hangarian algorithm 3.
Kuhn-Munkres algorithm</p>
<h2 id="adjacency-list">Adjacency list</h2>
<p>有几种形式, 以<code>adj[i]</code>表示以<span
class="math inline">\(i\)</span>为开头的边</p>
<p>应用: 各种图论算法</p>
<h3 id="vector">vector</h3>
<p>优点: 访问方便, 存图方便</p>
<p>缺点: 消耗空间, 容易<span class="math inline">\(MLE\)</span>;
删边速度慢</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> destination, weight;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; adj[<span class="number">1010</span>];</span><br></pre></td></tr></table></figure>
<p><strong>加边</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_EDGE(u, v, w) adj[u].push_back(Edge &#123;v, w&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>访问</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; adj[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  adj[u][i]...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[u]) &#123;</span><br><span class="line">  i...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="list">list</h3>
<p>优点: 添边删边速度快</p>
<p>缺点: 不易访问; 容易<span class="math inline">\(MLE\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> destination, weight;</span><br><span class="line">&#125;;</span><br><span class="line">std::list&lt;Edge&gt; adj[<span class="number">1010</span>];</span><br></pre></td></tr></table></figure>
<p><strong>加边</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_EDGE(u, v, w) adj[u].push_back(Edge &#123;v, w&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>访问</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> std::list&lt;Edge&gt;::iterator i = adj[u].<span class="built_in">begin</span>(); i != adj[u].<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">  *i...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[u]) &#123;</span><br><span class="line">  i...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 链式前向星</p>
<p>优点: 空间重复利用, 通常不会<span class="math inline">\(MLE\)</span>,
而且很快</p>
<p>缺点: 开小了会<span class="math inline">\(WA\)</span>, 开大了会<span
class="math inline">\(TLE\)</span>, 有时还会<span
class="math inline">\(RE\)</span></p>
<p>应用: 各种图论算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> destination, weight, next;</span><br><span class="line">&#125; edge[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">1010</span>], edge_count;</span><br></pre></td></tr></table></figure>
<p><strong>加边</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;u, <span class="type">const</span> <span class="type">int</span> &amp;v, <span class="type">const</span> <span class="type">int</span> &amp;w)</span> </span>&#123;</span><br><span class="line">  edge[edge_count] = Edge &#123;v, w, head[u]&#125;,</span><br><span class="line">  head[u] = edge_count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(head[u]); i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">  edge[i]...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小生成树">最小生成树</h1>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3366">Luogu
P3366 【模板】最小生成树</a></p>
<h2 id="kruskals-algorithm">Kruskal's algorithm</h2>
<p>将边以权值从小到大排序遍历, 用并查集加边, 同时维护答案。</p>
<p>特点: 适合稀疏图</p>
<p>时间复杂度: <span class="math inline">\(\Theta(|E| \lg |V|)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> begin, end, weight;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Edge &amp;another) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;weight &lt; another.weight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; edge[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> unions[<span class="number">5010</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    unions[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), u, v, w; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w),</span><br><span class="line">    edge[i] = Edge &#123;u, v, w&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">ans</span><span class="params">(Kruskal())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;orz&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unions[x] == x ? x : (unions[x] = <span class="built_in">Find</span>(unions[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  std::<span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">countt</span>(<span class="number">0</span>), u, v; i &lt; m; ++i) &#123;</span><br><span class="line">    u = <span class="built_in">Find</span>(edge[i].begin), v = <span class="built_in">Find</span>(edge[i].end);</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">      unions[v] = u,</span><br><span class="line">      ++countt,</span><br><span class="line">      ret += edge[i].weight;</span><br><span class="line">      <span class="keyword">if</span> (countt == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="prims-algorithm">Prim's algorithm</h2>
<p>随机选择一个结点作为树, 每次找与这棵树相连且不构成环的最小边加入进来,
形成生成树。</p>
<p>可以使用优先队列优化。</p>
<p>特点: 适合稠密图</p>
<p>时间复杂度: <span class="math inline">\(\Theta(|E| \lg |V|)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> destination, weight;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; adj[<span class="number">5010</span>];</span><br><span class="line"><span class="type">int</span> distance[<span class="number">5010</span>], vis[<span class="number">5010</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(distance, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(distance));</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), u, v, w; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(Edge &#123;v, w&#125;),</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(Edge &#123;u, w&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">ans</span><span class="params">(Prim())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;orz&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">countt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  distance[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, std::greater&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; Q;</span><br><span class="line">  Q.<span class="built_in">push</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">w</span><span class="params">(Q.top().first)</span>, <span class="title">u</span><span class="params">(Q.top().second)</span></span>;</span><br><span class="line">    Q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (!vis[u]) &#123;</span><br><span class="line">      ++countt,</span><br><span class="line">      ret += w,</span><br><span class="line">      vis[u] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.weight &lt; distance[i.destination]) &#123;</span><br><span class="line">          distance[i.destination] = i.weight, Q.<span class="built_in">push</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(distance[i.destination], i.destination));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret * (countt == n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="强连通分量">强连通分量</h1>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P2863">USACO
06 Jan. The Cow Prom</a> ## Tarjan's strongly connected components
algorithm</p>
<p>是基于对图深度优先搜索(DFS)的算法,
每个强连通分量为搜索树中的一棵子树。搜索时,
把当前搜索树中未处理的节点加入一个堆栈,
回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p>
<p>时间复杂度: <span class="math inline">\(\Theta(|V|+|E|)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; adj[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">10010</span>], low[<span class="number">10010</span>], color_count[<span class="number">10010</span>], indexx, countt;</span><br><span class="line"><span class="type">bool</span> instack[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Tarjan</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), u, v;i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">      <span class="built_in">Tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= countt; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (color_count[i] &gt; <span class="number">1</span>) ++ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;cur)</span> </span>&#123;</span><br><span class="line">  dfn[cur] = low[cur] = ++indexx;</span><br><span class="line">  S.<span class="built_in">push</span>(cur), instack[cur] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[cur]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">      <span class="built_in">Tarjan</span>(i);</span><br><span class="line">      low[cur] = std::<span class="built_in">min</span>(low[cur], low[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instack[i]) &#123;</span><br><span class="line">        low[cur] = std::<span class="built_in">min</span>(low[cur], low[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dfn[cur] == low[cur]) &#123;</span><br><span class="line">    ++countt;</span><br><span class="line">    <span class="keyword">while</span> (S.<span class="built_in">top</span>() != cur) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">node</span><span class="params">(S.top())</span></span>;</span><br><span class="line">      S.<span class="built_in">pop</span>(),</span><br><span class="line">      instack[node] = <span class="number">0</span>,</span><br><span class="line">      ++color_count[countt];</span><br><span class="line">    &#125;</span><br><span class="line">    S.<span class="built_in">pop</span>(),</span><br><span class="line">    ++color_count[countt],</span><br><span class="line">    instack[cur] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分图最大匹配">二分图最大匹配</h1>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3386">Luogu
P3386 【模板】二分图匹配</a> ## Hungarian algorithm
通过寻找增广路来计算最大匹配值</p>
<p>时间复杂度: 1. Adjacency matrix: <span
class="math inline">\(\Theta(n^3)\)</span> 2. Adjacency list: <span
class="math inline">\(\Theta(nm)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; adj[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n, m, e;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1010</span>], mate[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m ,&amp;e);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), u, v; i &lt; e; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n &amp;&amp; v &lt;= m) &#123;</span><br><span class="line">      adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Hungarian</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    ret += <span class="built_in">Match</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;cur)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[cur]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      vis[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (!mate[i] || <span class="built_in">Match</span>(mate[i])) &#123;</span><br><span class="line">        mate[i] = cur;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="二分图最佳匹配">二分图最佳匹配</h1>
<h2 id="kuhn-munkres-algorithm">Kuhn-Munkres algorithm</h2>
<p>是一种逐次修改可行顶标的方法,使之对应的等价子图逐次增广(增加边),最后出现完备匹配.</p>
<p>时间复杂度： <span class="math inline">\(\Theta(n^3)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">int</span> nl, nr;</span><br><span class="line"><span class="type">int</span> adj[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="type">int</span> mate[<span class="number">310</span>], dist_l[<span class="number">310</span>], dist_r[<span class="number">310</span>];</span><br><span class="line"><span class="type">int</span> slack[<span class="number">310</span>];</span><br><span class="line"><span class="type">bool</span> vis_l[<span class="number">310</span>], vis_r[<span class="number">310</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">BestMatch</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">KuhnMunkres</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;adj[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nl = nr = n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> ,<span class="built_in">KuhnMunkres</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">BestMatch</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;cur)</span> </span>&#123;</span><br><span class="line">  vis_l[cur] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">r</span>(<span class="number">0</span>); r &lt; nr; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis_r[r]) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">tmp</span><span class="params">(dist_l[cur] + dist_r[r] - adj[cur][r])</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">        vis_r[r] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!~mate[r] || <span class="built_in">BestMatch</span>(mate[r]))&#123;</span><br><span class="line">          mate[r] = cur;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(slack[r] &gt; tmp)</span><br><span class="line">        slack[r] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">KuhnMunkres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(mate, <span class="number">-1</span>, <span class="built_in">sizeof</span>(mate));</span><br><span class="line">  <span class="built_in">memset</span>(dist_r, <span class="number">0</span>, <span class="built_in">sizeof</span>(dist_r));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; nl; ++i) &#123;</span><br><span class="line">    dist_l[i] = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; nr; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (adj[i][j] &gt; dist_l[i]) &#123;</span><br><span class="line">        dist_l[i] = adj[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">l</span>(<span class="number">0</span>); l &lt; nl; ++l) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; nr; ++i) &#123;</span><br><span class="line">      slack[i] = <span class="number">0x7fffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(vis_l, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_l ),</span><br><span class="line">      <span class="built_in">memset</span>(vis_r, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis_r );</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">BestMatch</span>(l)) <span class="keyword">break</span>;</span><br><span class="line">      <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">d</span><span class="params">(<span class="number">0x7fffffff</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; nr; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis_r[i] &amp;&amp; d &gt; slack[i]) &#123;</span><br><span class="line">          d = slack[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; nl; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis_l[i]) &#123;</span><br><span class="line">          dist_l[i] -= d;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; nr; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis_r[i]) dist_r[i] += d;</span><br><span class="line">        <span class="keyword">else</span> slack[i] -= d;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; nr; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(~mate[i]) &#123;</span><br><span class="line">      res += adj[mate[i]][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最近公共祖先">最近公共祖先</h1>
<h2 id="heavy-path-decomposition">Heavy path decomposition</h2>
<p><del>学倍增和Tarjan的时候没好好学现在只会树链剖分</del></p>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3379">Luogu
P3379 【模板】最近公共祖先（LCA）</a></p>
<p>时间复杂度: 1. <code>Dfs1</code>: <span
class="math inline">\(\Theta(n)\)</span> 2. <code>Dfs2</code>: <span
class="math inline">\(\Theta(n)\)</span> 3.
<code>LowestCommonDivisor</code>: <span class="math inline">\(\Theta(\lg
n)\)</span></p>
<p><del>模板题要写读入优化过</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">GetCharacter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">2000000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> (p1 == p2) &amp;&amp;</span><br><span class="line">           (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">2000000</span>, stdin), p1 == p2) ? </span><br><span class="line">           EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DIGIT(c) (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    f = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> c = <span class="built_in">GetCharacter</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IS_DIGIT</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">GetCharacter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">IS_DIGIT</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">GetCharacter</span>();</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> IS_DIGIT</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; adj[<span class="number">500010</span>];</span><br><span class="line"><span class="type">int</span> heavy[<span class="number">500010</span>], size[<span class="number">500010</span>], father[<span class="number">500010</span>], top[<span class="number">500010</span>], depth[<span class="number">500010</span>];</span><br><span class="line"><span class="type">int</span> root, n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dfs1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;cur, <span class="type">const</span> <span class="type">int</span> &amp;fathernode)</span> </span>&#123;</span><br><span class="line">  size[cur] = <span class="number">1</span>;</span><br><span class="line">  father[cur] = fathernode;</span><br><span class="line">  depth[cur] = depth[fathernode] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[cur]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != fathernode) &#123;</span><br><span class="line">      size[cur] += <span class="built_in">Dfs1</span>(i, cur);</span><br><span class="line">      <span class="keyword">if</span> (size[i] &gt; size[heavy[cur]]) heavy[cur] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;cur, <span class="type">const</span> <span class="type">int</span> &amp;topnode)</span> </span>&#123;</span><br><span class="line">  top[cur] = topnode;</span><br><span class="line">  <span class="keyword">if</span> (heavy[cur]) &#123;</span><br><span class="line">    <span class="built_in">Dfs2</span>(heavy[cur], topnode);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[cur]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (heavy[cur] != i &amp;&amp; father[cur] != i) &#123;</span><br><span class="line">        <span class="built_in">Dfs2</span>(i, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LowestCommonAncestor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x, <span class="type">const</span> <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(x)</span>, <span class="title">b</span><span class="params">(y)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (top[a] != top[b]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[top[a]] &lt; depth[top[b]]) std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">    a = father[top[a]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depth[a] &gt; depth[b] ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Read</span>(n), <span class="built_in">Read</span>(m), <span class="built_in">Read</span>(root);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>), u, v; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">Read</span>(u), <span class="built_in">Read</span>(v);</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v), adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dfs1</span>(root, root);</span><br><span class="line">  <span class="built_in">Dfs2</span>(root, root);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">Read</span>(u), <span class="built_in">Read</span>(v);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">LowestCommonAncestor</span>(u, v));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路">最短路</h1>
<h2 id="floyd-warshall-algorithm">Floyd-Warshall algorithm</h2>
<p>枚举每一个结点作为中间点, 再枚举每一个起点和终点,
可以松弛就进行松弛。</p>
<p>时间复杂度: <span class="math inline">\(\Theta(n^3)\)</span></p>
<p>题目链接: <a
target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">HDU 2544
最短路</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">int</span> adj[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) &amp;&amp; (n || m)) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(adj, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(adj));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>), u, v, w; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">      adj[u][v] = adj[v][u] = std::<span class="built_in">min</span>(adj[u][v], w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) adj[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">k</span>(<span class="number">1</span>); k &lt;= n; ++k) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">j</span>(<span class="number">1</span>); j &lt;= n; ++j) &#123;</span><br><span class="line">          adj[j][i] = adj[i][j] = std::<span class="built_in">min</span>(adj[i][j], adj[i][k] + adj[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, adj[<span class="number">1</span>][n]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shortest-path-faster-algorithmspfa">Shortest Path Faster
Algorithm(SPFA)</h2>
<p>是Bellman-Ford algorithm的改进, 通常情况下不会出什么问题,
但精心设计的稠密图可以轻易卡掉SPFA, 使用需谨慎。</p>
<p>平均时间复杂度: <span class="math inline">\(\Theta(|E|)\)</span></p>
<p>理论上界: <span class="math inline">\(\Theta(|V||E|)\)</span></p>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3371">Luogu
P3371 【模板】单源最短路径（弱化版）</a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> destination, weight;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; adj[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> distance[<span class="number">10010</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ShortestPathFasterAlgorithm</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), u, v, w; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(Edge &#123;v, w&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ShortestPathFasterAlgorithm</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, distance[i] == <span class="number">0x3f3f3f3f</span> ? <span class="number">2147483647</span> : distance[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ShortestPathFasterAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(distance, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(distance));</span><br><span class="line">  distance[s] = <span class="number">0</span>;</span><br><span class="line">  std::deque&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">  Q.<span class="built_in">push_back</span>(s);</span><br><span class="line">  vis[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">cur</span><span class="params">(Q.front())</span></span>;</span><br><span class="line">    Q.<span class="built_in">pop_front</span>();</span><br><span class="line">    vis[cur] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[cur]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (distance[i.destination] &gt; distance[cur] + i.weight) &#123;</span><br><span class="line">        distance[i.destination] = distance[cur] + i.weight;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i.destination]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (distance[i.destination] &lt; distance[Q.<span class="built_in">front</span>()]) Q.<span class="built_in">push_front</span>(i.destination);</span><br><span class="line">          <span class="keyword">else</span> Q.<span class="built_in">push_back</span>(i.destination);</span><br><span class="line">          vis[i.destination] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="dijkstras-algorithm">Dijkstra's algorithm</h2>
<p>与最小生成树的Prim's algorithm相像, 主要思想为贪心,
适用于稠密图。</p>
<p>通常情况下使用SPFA, 如果数据卡SPFA可以尝试堆优化的Dijkstra's
algorithm。</p>
<p>时间复杂度: <span class="math inline">\(\Theta((|E|)\lg
|E|)\)</span></p>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P4779">Luogu
P4779 【模板】单源最短路径（标准版）</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; adj[<span class="number">100010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> distance[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">register</span> std::priority_queue&lt;std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; &gt;, std::greater&lt;std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; &gt; &gt; Q;</span><br><span class="line">  <span class="built_in">memset</span>(distance, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(distance));</span><br><span class="line">  distance[s] = <span class="number">0</span>;</span><br><span class="line">  Q.<span class="built_in">push</span>(std::<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;(<span class="number">0ll</span>, s));</span><br><span class="line">  <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">cur</span><span class="params">(Q.top().second)</span></span>;</span><br><span class="line">    Q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (!vis[cur]) &#123;</span><br><span class="line">      vis[cur] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i : adj[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (distance[i.first] &gt; distance[cur] + i.second) &#123;</span><br><span class="line">          distance[i.first] = distance[cur] + i.second;</span><br><span class="line">          Q.<span class="built_in">push</span>(std::<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;(distance[i.first], i.first));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>), u, v, w; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt;(v, (<span class="type">long</span> <span class="type">long</span>)(w)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dijkstra</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(i == n ? <span class="string">&quot;%lld\n&quot;</span> : <span class="string">&quot;%lld &quot;</span>, distance[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大流">最大流</h1>
<h2 id="edmonds-karp-algorithm">Edmonds-Karp algorithm</h2>
<p>最大流的基础方法, 思想非常简单:</p>
<p>每次BFS找到一条增广路进行增广, 记录该路径上可增广的最大流,
在图中减去即可。、</p>
<p>时间复杂度: <span class="math inline">\(\Theta(|V||E|^2)\)</span></p>
<p>题目链接: <a
target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P2740">USACO4.2 Drainage
Ditches</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="type">int</span> predeccessor[<span class="number">210</span>], flow[<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> G[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Bfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;S, <span class="type">const</span> <span class="type">int</span> &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">register</span> std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(predeccessor, <span class="number">-1</span>, <span class="built_in">sizeof</span>(predeccessor));</span><br><span class="line">  predeccessor[S] = <span class="number">0</span>;</span><br><span class="line">  flow[S] = INF;</span><br><span class="line">  q.<span class="built_in">push</span>(S);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">current</span><span class="params">(q.front())</span></span>;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (current == T) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (G[current][i] &amp;&amp; predeccessor[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        predeccessor[i] = current;</span><br><span class="line">        flow[i] = std::<span class="built_in">min</span>(flow[current], G[current][i]);</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> predeccessor[T] == <span class="number">-1</span> ? <span class="number">-1</span> : flow[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">EdmondsKarp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;S, <span class="type">const</span> <span class="type">int</span> &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">increase</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>((increase = <span class="built_in">Bfs</span>(S, T)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">current</span><span class="params">(T)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (current != S) &#123;</span><br><span class="line">      G[predeccessor[current]][current] -= increase;</span><br><span class="line">      G[current][predeccessor[current]] += increase;</span><br><span class="line">      current = predeccessor[current];</span><br><span class="line">    &#125;</span><br><span class="line">    ret += increase;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), u, v, w; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    G[u][v] += w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">EdmondsKarp</span>(<span class="number">1</span>, n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dinics-algorithm">Dinic's algorithm</h2>
<p>首先利用BFS对网络进行分层,
然后利用DFS从前一层向后一层反复寻找增广路(利用回溯),
当这次DFS无法继续增广时, 重复BFS步骤, 直到BFS无法到达汇点时,
算法结束。</p>
<p>时间复杂度: <span class="math inline">\(\Theta(|V|^2
|E|)\)</span></p>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3376">Luogu
P3376 【模板】网络最大流</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="type">int</span> depth[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> destination, maxflow, next;</span><br><span class="line">  <span class="built_in">Edge</span>() &#123;</span><br><span class="line">    destination = maxflow = next = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; edge[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;u, <span class="type">const</span> <span class="type">int</span> &amp;v, <span class="type">const</span> <span class="type">int</span> &amp;w)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">edge_count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  edge[edge_count].destination = v;</span><br><span class="line">  edge[edge_count].maxflow = w;</span><br><span class="line">  edge[edge_count].next = head[u];</span><br><span class="line">  head[u] = edge_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">BreadthFirstSearch</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;S, <span class="type">const</span> <span class="type">int</span> &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">register</span> std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(depth, <span class="number">0</span>, <span class="built_in">sizeof</span>(depth));</span><br><span class="line">  depth[S] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(S);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">current</span><span class="params">(q.front())</span></span>;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(head[current]); i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (edge[i].maxflow &amp;&amp; !depth[edge[i].destination]) &#123;</span><br><span class="line">        depth[edge[i].destination] = depth[current] + <span class="number">1</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(edge[i].destination);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depth[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">DepthFirstSearch</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;current, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">register</span> <span class="type">int</span> maxflow, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> <span class="type">int</span> &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current == T) <span class="keyword">return</span> maxflow;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(head[current]); i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[edge[i].destination] == depth[current] + <span class="number">1</span> &amp;&amp; edge[i].maxflow) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">delta</span><span class="params">(DepthFirstSearch(edge[i].destination, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          std::min(maxflow, edge[i].maxflow), </span></span></span><br><span class="line"><span class="params"><span class="function">                                          T))</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">        edge[i].maxflow -= delta;</span><br><span class="line">        edge[i ^ <span class="number">1</span>].maxflow += delta;</span><br><span class="line">        <span class="keyword">return</span> delta;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Dinic</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;S, <span class="type">const</span> <span class="type">int</span> &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span>, delta</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">BreadthFirstSearch</span>(S, T)) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((delta = <span class="built_in">DepthFirstSearch</span>(S, <span class="number">0x3f3f3f3f</span>, T))) &#123;</span><br><span class="line">      ret += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">1</span>), u, v, w; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    <span class="built_in">AddEdge</span>(u, v, w), <span class="built_in">AddEdge</span>(v, u, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Dinic</span>(s, t));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小费用最大流">最小费用最大流</h1>
<h2 id="dinics-algorithm-1">Dinic's algorithm</h2>
<p>将费用看作路径长度, 把Dinic's algorithm中的BFS换成SPFA,
每次找费用最小的进行增广</p>
<p>时间复杂度: <span class="math inline">\(\Theta(|V|^2
|E|)\)</span></p>
<p>题目链接: <a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3381">Luogu
P3381 【模板】最小费用最大流</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> destination, maxflow, cost, next;</span><br><span class="line">  <span class="built_in">Edge</span>() &#123;</span><br><span class="line">    destination = maxflow = cost = next = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; edge[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">5010</span>];</span><br><span class="line"><span class="type">int</span> distance[<span class="number">5010</span>], pre_node[<span class="number">5010</span>], pre_edge[<span class="number">5010</span>], flow[<span class="number">5010</span>], vis[<span class="number">5010</span>];</span><br><span class="line"><span class="type">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;u, <span class="type">const</span> <span class="type">int</span> &amp;v, <span class="type">const</span> <span class="type">int</span> &amp;w, <span class="type">const</span> <span class="type">int</span> &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">edge_count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  edge[edge_count].destination = v;</span><br><span class="line">  edge[edge_count].maxflow = w;</span><br><span class="line">  edge[edge_count].cost = c;</span><br><span class="line">  edge[edge_count].next = head[u];</span><br><span class="line">  head[u] = edge_count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ShortestPathFasterAlgorithm</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;S, <span class="type">const</span> <span class="type">int</span> &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(distance, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(distance));</span><br><span class="line">  <span class="built_in">memset</span>(flow, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(flow));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">register</span> std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(S);</span><br><span class="line">  vis[S] = <span class="number">1</span>, distance[S] = <span class="number">0</span>, pre_node[T] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">current</span><span class="params">(q.front())</span></span>;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[current] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(head[current]); i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (edge[i].maxflow &amp;&amp; </span><br><span class="line">          distance[edge[i].destination] &gt; distance[current] + edge[i].cost) &#123;</span><br><span class="line">        distance[edge[i].destination] = distance[current] + edge[i].cost;</span><br><span class="line">        pre_node[edge[i].destination] = current;</span><br><span class="line">        pre_edge[edge[i].destination] = i;</span><br><span class="line">        flow[edge[i].destination] = std::<span class="built_in">min</span>(flow[current], edge[i].maxflow);</span><br><span class="line">        <span class="keyword">if</span> (!vis[edge[i].destination]) &#123;</span><br><span class="line">          vis[edge[i].destination] = <span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(edge[i].destination);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre_node[T] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dinic</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;S, <span class="type">const</span> <span class="type">int</span> &amp;T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ShortestPathFasterAlgorithm</span>(S, T)) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">register</span> <span class="type">int</span> <span class="title">current</span><span class="params">(T)</span></span>;</span><br><span class="line">    maxflow += flow[T];</span><br><span class="line">    mincost += flow[T] * distance[T];</span><br><span class="line">    <span class="keyword">while</span> (current != S) &#123;</span><br><span class="line">      edge[pre_edge[current]].maxflow -= flow[T];</span><br><span class="line">      edge[pre_edge[current] ^ <span class="number">1</span>].maxflow += flow[T];</span><br><span class="line">      current = pre_node[current];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> <span class="built_in">i</span>(<span class="number">0</span>), u, v, w, c; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w, &amp;c);</span><br><span class="line">    <span class="built_in">AddEdge</span>(u, v, w, c), <span class="built_in">AddEdge</span>(v, u, <span class="number">0</span>, -c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Dinic</span>(s, t);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag"># 图论</a>
              <a href="/tags/Kruskal%E7%AE%97%E6%B3%95/" rel="tag"># Kruskal算法</a>
              <a href="/tags/Prim%E7%AE%97%E6%B3%95/" rel="tag"># Prim算法</a>
              <a href="/tags/Tarjan%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%AE%97%E6%B3%95/" rel="tag"># Tarjan强连通分量算法</a>
              <a href="/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/" rel="tag"># 匈牙利算法</a>
              <a href="/tags/Kuhn-Munkres%E7%AE%97%E6%B3%95/" rel="tag"># Kuhn-Munkres算法</a>
              <a href="/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/" rel="tag"># 树链剖分</a>
              <a href="/tags/Floyd-Warshall%E7%AE%97%E6%B3%95/" rel="tag"># Floyd-Warshall算法</a>
              <a href="/tags/SPFA/" rel="tag"># SPFA</a>
              <a href="/tags/Dijkstra%E7%AE%97%E6%B3%95/" rel="tag"># Dijkstra算法</a>
              <a href="/tags/Edmonds-Karp%E7%AE%97%E6%B3%95/" rel="tag"># Edmonds-Karp算法</a>
              <a href="/tags/Dinic%E7%AE%97%E6%B3%95/" rel="tag"># Dinic算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/09/29/UVa-12034-Race-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" rel="prev" title="UVa 12034 Race (组合数学)">
                  <i class="fa fa-angle-left"></i> UVa 12034 Race (组合数学)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/10/08/NOIp-2018-%E5%89%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90%E6%80%BB%E7%BB%93/" rel="next" title="NOIp 2018 前的字符串板子总结">
                  NOIp 2018 前的字符串板子总结 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2018 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sifr</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/shifuru" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
